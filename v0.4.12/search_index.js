var documenterSearchIndex = {"docs":
[{"location":"man/read/#Introduction","page":"Reading and Writing","title":"Introduction","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The DLMReader package has the filereader and filerwriter functions for reading and writing delimited files, respectively. They have a few keyword arguments which we explain each of them in this section.","category":"page"},{"location":"man/read/#filereader","page":"Reading and Writing","title":"filereader","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User must pass the file name as the first argument of filereader to read a delimited file into Julia, i.e. filereader(path; ...). The filereader function assumes that the observations are separated by comma and the first line of the input file contains the columns' name, additionally, it assumes that the strings are not quoted. It scans the first 20 lines of the input file to detect Int64 and Float64 columns, and use String as the default type when the detection goes wrong. Thus, for a well-formatted csv file, user does not need to use any keyword argument. However, the filereader function provides some keyword arguments to give user extra flexibility for reading complex delimited files.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"filereader treats empty strings and \".\" as missing","category":"page"},{"location":"man/read/#Keyword-arguments","page":"Reading and Writing","title":"Keyword arguments","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"types\ndelimiter\ndlmstr\nignorerepeated\nheader\nlinebreak\nguessingrows\nfixed\nquotechar\nescapechar\ndtformat\nint_base\ninformat\nskipto\nlimit\nmultiple_obs\nline_informat\nbuffsize\nlsize\nstring_trim\nmakeunique\nemptycolname\nwarn\neolwarn\nthreads\nthreshold","category":"page"},{"location":"man/read/#types","page":"Reading and Writing","title":"types","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User can pass the types of each column of the input file by using the types keyword argument. User may pass a vector of types which includes every type of each column, or may pass a dictionary of types for few selected columns.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: auto detection","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1,x2\n       12,13\n       1,2\n       \"\"\"), types = [Int, Float64])\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Float64? \n─────┼────────────────────\n   1 │       12      13.0\n   2 │        1       2.0","category":"page"},{"location":"man/read/#delimiter","page":"Reading and Writing","title":"delimiter","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"To change the default delimiter, user must pass the delimiter keyword argument. The delimiter keyword argument only accept Char as delimiter. Additionally, user can pass a vector of Char which causes filereader to use them as alternative delimiters.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: comma","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1;x2\n       12;13\n       1;2\n       \"\"\"), delimiter = ';')\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │       12        13\n   2 │        1         2","category":"page"},{"location":"man/read/#dlmstr","page":"Reading and Writing","title":"dlmstr","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"This keyword argument is used to pass a string as the delimiter for values.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1|:|x2\n       12|:|13\n       1|:|2\n       \"\"\"), dlmstr = \"|:|\" )\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │       12        13\n   2 │        1         2","category":"page"},{"location":"man/read/#ignorerepeated","page":"Reading and Writing","title":"ignorerepeated","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"If it is set as true, repeated delimiters will be ignored.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1,,x2\n       12,13\n       1,,,,2\n       \"\"\"), ignorerepeated = true)\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │       12        13\n   2 │        1         2","category":"page"},{"location":"man/read/#header","page":"Reading and Writing","title":"header","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User must set this as false if the first line of the input file is not the column header. Additionally, user can pass a vector of columns' name, which will be used as the columns' header.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: true","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"\n       12,13\n       1,2\n       \"\"\"), header = [:Col1, :Col2])\n2×2 Dataset\n Row │ Col1      Col2     \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │       12        13\n   2 │        1         2","category":"page"},{"location":"man/read/#linebreak","page":"Reading and Writing","title":"linebreak","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The filereader function use the value of this option as line separator. It can accept a Char or a vector of Char where the length of the vector is less than or equal two. For some rare cases user may need to pass this option to assist filereader in reading the input file.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: auto detection","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"\n       x1,x2;12,13;1,2;\"\"\"), linebreak = ';')\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │       12        13\n   2 │        1         2","category":"page"},{"location":"man/read/#guessingrows","page":"Reading and Writing","title":"guessingrows","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"This provide the number of lines to be used for types detection. The filereader function will detect the types of the column more accurately if user increase this value, however, it costs more computation time.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 20","category":"page"},{"location":"man/read/#fixed","page":"Reading and Writing","title":"fixed","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"This option is used for reading fixed width files. User must pass a dictionary of columns' locations (as a range) for reading a fixed width file.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"\n       12\n       34\n       \"\"\"), fixed = Dict(1=>1:1, 2=>2:2), header = false)\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         2\n   2 │        3         4","category":"page"},{"location":"man/read/#quotechar","page":"Reading and Writing","title":"quotechar","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"If the texts are quoted in the input file, user must pass the quoted character via this keyword argument.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing (the filereader assumes the texts are not quoted)","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1,x2\n       \"12\",13\n       \"1\",2\n       \"\"\"), quotechar = '\"')\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │       12        13\n   2 │        1         2","category":"page"},{"location":"man/read/#escapechar","page":"Reading and Writing","title":"escapechar","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Declaring the escape char for quoted text.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing (the filereader assumes the text are not quoted)","category":"page"},{"location":"man/read/#dtformat","page":"Reading and Writing","title":"dtformat","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User must pass the date format of DataTime columns if they are different from the standard format. The dtformat keyword argument accept a dictionary of values.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"date1,date2\n       2020-1-1,2020/1/1\n       2020-2-2,2020/2/2\n       \"\"\"), dtformat = Dict(1 => dateformat\"y-m-d\", 2 => dateformat\"y/m/d\"))\n2×2 Dataset\n Row │ date1       date2      \n     │ identity    identity   \n     │ Date?       Date?      \n─────┼────────────────────────\n   1 │ 2020-01-01  2020-01-01\n   2 │ 2020-02-02  2020-02-02","category":"page"},{"location":"man/read/#int_base","page":"Reading and Writing","title":"int_base","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The filereader can read integers with with given base. User can pass this information for a specific column.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1,x2\n       100,100\n       101,101\n       \"\"\"), int_base = Dict(1 => 2))\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        4       100\n   2 │        5       101","category":"page"},{"location":"man/read/#informat","page":"Reading and Writing","title":"informat","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User can pass a dictionary which provides the information of the informat of selected columns.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1,x2\n       NA,12\n       1,NA\n       \"\"\"), informat = Dict(1:2 .=> NA!))\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │  missing        12\n   2 │        1   missing ","category":"page"},{"location":"man/read/#skipto","page":"Reading and Writing","title":"skipto","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"It can be used to start reading a file from specific location.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 1","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"COL1, COL2\n       1,2\n       2,3\n       3,4\n       \"\"\"), skipto = 3, header = false)\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        2         3\n   2 │        3         4","category":"page"},{"location":"man/read/#limit","page":"Reading and Writing","title":"limit","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"It can be used to limit the number of observations read from the input file.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: Inf","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"COL1, COL2\n       1,2\n       2,3\n       3,4\n       \"\"\"), limit = 1)\n1×2 Dataset\n Row │ COL1      COL2     \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         2","category":"page"},{"location":"man/read/#multiple_obs","page":"Reading and Writing","title":"multiple_obs","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"If it is set as true, the filereader function assumes there may be more than one observation in each line of the input file.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"1,2,3,4,5\n       6,7\n       \"\"\"), multiple_obs = true, header = [:x1, :x2], types = [Int, Int])\n4×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         2\n   2 │        3         4\n   3 │        5         6\n   4 │        7   missing ","category":"page"},{"location":"man/read/#line_informat","page":"Reading and Writing","title":"line_informat","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User can provide line informat via this keyword argument.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/#buffsize","page":"Reading and Writing","title":"buffsize","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"User can provide any positive number for the buffer size. Each thread allocates the amount of buffsize and reads the values from the input file into it.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 2^16","category":"page"},{"location":"man/read/#lsize","page":"Reading and Writing","title":"lsize","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"It indicated the line buffer size for reading the input files. For very wide table use may need to manually adjust this option. Its value must be less than buffsize.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 2^15","category":"page"},{"location":"man/read/#string_trim","page":"Reading and Writing","title":"string_trim","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Setting this as true will trim the trailing blanks of strings before storing them into the output data set.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"DLMReader shipped with the STRIP! informat which can be used to strip (removing leading and trailing blanks) any raw text before parsing.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x1,x2\n       \"    fdh  \",df\n       \"dkhfd    \",dfadf\n       \"\"\"), quotechar = '\"', string_trim = true)\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ String?   String?  \n─────┼────────────────────\n   1 │     fdh   df\n   2 │ dkhfd     dfadf\n\njulia> ds[:, :x1]\n2-element Vector{Union{Missing, String}}:\n \"    fdh\"\n \"dkhfd\"\n\njulia> ds = filereader(IOBuffer(\"\"\"x1,x2,x3\n       1,   2020-2-2   , \" ff  \"\n       2,2020-1-1,\"343\"\n       \"\"\"), types = Dict(2 => Date), quotechar = '\"', informat = Dict(2:3 .=> STRIP!))\n2×3 Dataset\n Row │ x1        x2          x3       \n     │ identity  identity    identity \n     │ Int64?    Date?       String?  \n─────┼────────────────────────────────\n   1 │        1  2020-02-02  ff\n   2 │        2  2020-01-01  343\n\njulia> ds[:, :x3]\n2-element Vector{Union{Missing, String}}:\n \"ff\"\n \"343\"","category":"page"},{"location":"man/read/#makeunique","page":"Reading and Writing","title":"makeunique","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"If there are non-unique columns' names, this can resolve it by adding a suffix to the names.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x,x\n       1,2\n       \"\"\"), makeunique = true)\n1×2 Dataset\n Row │ x         x_1      \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         2","category":"page"},{"location":"man/read/#emptycolname","page":"Reading and Writing","title":"emptycolname","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"If it is set to true, it generates a column name for columns with empty name.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"julia> ds = filereader(IOBuffer(\"\"\"x,\n       1,2\n       \"\"\"), emptycolname = true)\n1×2 Dataset\n Row │ x         NONAME1  \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         2","category":"page"},{"location":"man/read/#warn","page":"Reading and Writing","title":"warn","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Control the maximum number of warning and information. Setting it to 0 will suppress warnings and information during reading the input file.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 20","category":"page"},{"location":"man/read/#eolwarn","page":"Reading and Writing","title":"eolwarn","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Control if the end-of-line character warning should be shown.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: true","category":"page"},{"location":"man/read/#threads","page":"Reading and Writing","title":"threads","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"For large files, the filereader function exploits all threads. However, this can be switch off by setting this argument as false.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: true","category":"page"},{"location":"man/read/#threshold","page":"Reading and Writing","title":"threshold","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The file size threshold (in bytes) which specifies the minimum file size for switching to the high performance algorithm.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 2^26","category":"page"},{"location":"man/read/#filewriter","page":"Reading and Writing","title":"filewriter","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The filewriter function writes a data set into disk. Behind the scene, it uses byrow function from InMemoryDatasets.jl to efficiently convert each row of the input data set into UInt8. The first argument of the filewriter must be a filename and the second argument must be the passed data set.","category":"page"},{"location":"man/read/#Keyword-arguments-2","page":"Reading and Writing","title":"Keyword arguments","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"delimiter\nquotechar\nmapformats\nappend\nheader\nbuffsize\nlsize\nthreads","category":"page"},{"location":"man/read/#delimiter-2","page":"Reading and Writing","title":"delimiter","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"By default, filewriter uses comma as delimiter, however, user can pass any other Char (or a vector of Char) via the delimiter keyword argument.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: comma","category":"page"},{"location":"man/read/#quotechar-2","page":"Reading and Writing","title":"quotechar","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The filewriter function does not quote values, if this is desired, the quote Char must be passed via the quotechar keyword argument.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: nothing","category":"page"},{"location":"man/read/#mapformats","page":"Reading and Writing","title":"mapformats","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Setting this as true causes filewriter to write the formatted values.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/#append","page":"Reading and Writing","title":"append","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Setting this as true causes filewriter to append values to the end of the input file.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: false","category":"page"},{"location":"man/read/#header-2","page":"Reading and Writing","title":"header","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"The filewriter function writes column names in the output file, however, this can be prevented by setting header = false.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: true","category":"page"},{"location":"man/read/#buffsize-2","page":"Reading and Writing","title":"buffsize","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"This option controls the buffer size. ","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: 2^24","category":"page"},{"location":"man/read/#lsize-2","page":"Reading and Writing","title":"lsize","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"This option controls the line size for writing values.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: auto detection","category":"page"},{"location":"man/read/#threads-2","page":"Reading and Writing","title":"threads","text":"","category":"section"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"If set true, filewriter exploits all threads.","category":"page"},{"location":"man/read/","page":"Reading and Writing","title":"Reading and Writing","text":"Default: true","category":"page"},{"location":"man/gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"multiple observation per line:","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> filereader(IOBuffer(\"1,2,3,4,5\\n6,7,8\\n10\\n\"),\n                  header = [:x1, :x2],\n                  types = [Int, Int],\n                  multiple_obs = true)\n5×2 Dataset\n Row │ x1        x2       \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         2\n   2 │        3         4\n   3 │        5         6\n   4 │        7         8\n   5 │       10   missing","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"Reading computer outputs: ","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> filereader(IOBuffer(\"\"\" name1 name2 avg1 avg2  y\n              0   A   D   75   5    32\n              1   A   D   75   5    32\n              2   D   L   32   7    12\n              3   F   C   99   8    42\n              4   F   C   99   8    42\n              5   C   A   43   6    39\n              6   C   A   43   6    39\n              7   L   R   53   3    11\n              8   R   F   21   2    25\n              9   R   F   21   2    25\n              \"\"\"), delimiter = ' ', ignorerepeated = true, emptycolname = true)\n10×6 Dataset\n Row │ NONAME1   name1     name2     avg1      avg2      y        \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    String?   String?   Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │        0  A         D               75         5        32\n   2 │        1  A         D               75         5        32\n   3 │        2  D         L               32         7        12\n   4 │        3  F         C               99         8        42\n   5 │        4  F         C               99         8        42\n   6 │        5  C         A               43         6        39\n   7 │        6  C         A               43         6        39\n   8 │        7  L         R               53         3        11\n   9 │        8  R         F               21         2        25\n  10 │        9  R         F               21         2        25","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"Removing (.*?) and dealing with £:","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> function INFMT!(x)\n           remove!(x, findfirst(r\"\\(.*?\\)\", x))\n       end\n           \nINFMT! (generic function with 1 method)\n\njulia> register_informat(INFMT!)\n[ Info: Informat INFMT! has been registered\n\njulia> function RM£!(x)\n         remove!(x, \"£\")\n      end\njulia> register_informat(RM£!)\n[ Info: Informat RM£! has been registered\n\njulia> filereader(IOBuffer(\"\"\"x1;x2\n            1(comment);£12,000.00\n            2;£(100.00)\n            3;£(10,000.00)\n       \"\"\"), delimiter = ';', informat = Dict(1 => INFMT!, 2 => RM£! ∘ COMMA! ∘ ACC!))\n3×2 Dataset\n Row │ x1        x2       \n     │ identity  identity \n     │ Int64?    Float64? \n─────┼────────────────────\n   1 │        1   12000.0\n   2 │        2    -100.0\n   3 │        3  -10000.0","category":"page"},{"location":"man/tutorial_basic/#Tutorial-Basics","page":"Basic","title":"Tutorial - Basics","text":"","category":"section"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"This section provides a tutorial for using the DLMReader package to read a delimited file into Julia. To start using the package enter the following expression in a Julia session","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> using DLMReader","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"If you have not installed the package yet, you will be prompt to do it so.","category":"page"},{"location":"man/tutorial_basic/#Reading-a-csv-file","page":"Basic","title":"Reading a csv file","text":"","category":"section"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"The tutorial_1.csv file is available as part of the DLMReader package and the following expression creates a file reference to its location,","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> fname = joinpath(dirname(pathof(DLMReader)),\n                                \"..\", \"docs\", \"src\", \"assets\", \"tutorial_1.csv\"\n                            );","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"The filereader function is an exported function for reading delimited files into Julia. By default, the filereader function uses comma to separate values in a file, however, the delimiter of tutorial_file is \";\", so we pass this to the filereader function via the delimiter keyword argument.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> tutorial = filereader(fname, delimiter = ';')\n3×4 Dataset\n Row │ x1        x2        x3|value  date       \n     │ identity  identity  identity  identity   \n     │ Int64?    String?   String?   String?    \n─────┼──────────────────────────────────────────\n   1 │        1  2,30      ab|2      2022-01-02\n   2 │       10  -2,10     cd|3      2022-19-20\n   3 │        4  1,34      dd|       2022-02-13","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"Note that you should pass the file delimiter as Char to the delimiter keyword arguments. ","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"By default, the filereader function assumes that the first line of the file contains the column names, and it uses this to create column name for the output data set as shown in this example.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"The output data set is a Dataset which is a special type for working with tabular data in Julia, see the InMemoryDatasets.jl package for more information about working with tabular data in Julia.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"From the output data set, we observe that the third column is actually a mix of two columns which are separated by |. This means that our delimited file is using alternative delimiters for separating values, so we should provide this information to the filereader function to help it correctly parse the input file. To use alternative delimiters we must pass a vector of delimiters to the delimiter keyword argument:","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> tutorial = filereader(fname, delimiter = [';','|'])\n3×5 Dataset\n Row │ x1        x2        x3        value     date       \n     │ identity  identity  identity  identity  identity   \n     │ Int64?    String?   String?   Int64?    String?    \n─────┼────────────────────────────────────────────────────\n   1 │        1  2,30      ab               2  2022-01-02\n   2 │       10  -2,10     cd               3  2022-19-20\n   3 │        4  1,34      dd         missing  2022-02-13","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"Note that by passing [';', '|'] as delimiter, filereader correctly reads the :x3 and :value columns into Julia.","category":"page"},{"location":"man/tutorial_basic/#Dealing-with-Date-and-Time","page":"Basic","title":"Dealing with Date and Time","text":"","category":"section"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"The last column of the tutorial_1.csv file is a Date type, however, it is read as String. This is the default behaviour of filereader. User may force the type of a specific column by passing a vector or a Dict as the types keyword argument. If user is willing to specify every column's type, s/he should use a vector of types with the same length of the number of columns as the value of the types keyword argument, e.g. in the above example [Int, String, String, Int, Date] would be fine, however, since we are only interested to correct the type of the fifth column, we can pass it in Dict to the types keyword argument:","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> tutorial = filereader(fname, delimiter = [';','|'], types = Dict(5 => Date))\n┌ Warning: There are problems with parsing file at line 3 (observation 2) : \n│ Column 5 : date : Read from buffer (\"2022-19-20\")\n│ the values are set as missing.\n│ MORE DETAILS: \n│ x1::Int64 = 10, x2::String = -2,10, x3::String = cd, value::Int64 = 3, date::Date = missing\n│ 10;-2,10;cd|3;2022-19-20\n└ @ DLMReader ...\n3×5 Dataset\n Row │ x1        x2        x3        value     date       \n     │ identity  identity  identity  identity  identity   \n     │ Int64?    String?   String?   Int64?    Date?      \n─────┼────────────────────────────────────────────────────\n   1 │        1  2,30      ab               2  2022-01-02\n   2 │       10  -2,10     cd               3  missing    \n   3 │        4  1,34      dd         missing  2022-02-13","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"By default, the filereader function assumes that the column with the Date type are in the standard format, i.e. yyyy-mm-dd, and it will try to parse each value using the date format, however, if a value is not parsable filereader parses it as missing, and it shows a warning message to indicate that the parser fails to parse the specific value and provide some information about this. If the value should be treated as missing, user may ignore the warning message. For instance, in the above example, the issue is due to the fact that 19 is not a correct value for a month, so it must be a data entry error.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"If values for date(time) are not represented as yyyy-mm-dd format, user can use the dtformat keyword argument to provide the right date format of a specific column. User must pass a dictionary of date format for specifying the date format:","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> tutorial = filereader(fname, delimiter = [';','|'], \n                              types = Dict(5 => Date), \n                              dtformat = Dict(5 => dateformat\"y-m-d\"));","category":"page"},{"location":"man/tutorial_basic/#Using-\"informats\"","page":"Basic","title":"Using \"informats\"","text":"","category":"section"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"The DLMReader package provides special functionality, called informat, to allow modification of the raw text before the parsing phase, i.e. informat is a special function which will be called on the raw text of a value before sending the text to the parser. The DLMReader package is shipped with some predefined informats, however, power users can define their own informats for special purposes.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"We are going to use one of the predefined informats to parse the second column of tutorial_1.csv file. The second column of tutorial_1.csv file uses \",\" as decimal point in numbers, this is a common practice in some european countries. To parse this column correctly, we can call the COMMAX! informat before parsing its values. The COMMAX! informat converts \",\" to decimal points, and removes \".\" (thousand separator) and \"€\" (U+20AC) from the numbers.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> tutorial = filereader(fname, delimiter = [';','|'], \n                              types = Dict(5 => Date), \n                              informat = Dict(2 => COMMAX!))\n┌ Warning: There are problems with parsing file at line 3 (observation 2) :  \n│ Column 5 : date : Read from buffer (\"2022-19-20\")\n│ the values are set as missing.\n│ MORE DETAILS: \n│ x1::Int64 = 10, x2::Float64 = -2.1, x3::String = cd, value::Int64 = 3, date::Date = missing\n│ 10;-2.10;cd|3;2022-19-20\n└ @ DLMReader ...\n3×5 Dataset\n Row │ x1        x2        x3        value     date       \n     │ identity  identity  identity  identity  identity   \n     │ Int64?    Float64?  String?   Int64?    Date?      \n─────┼────────────────────────────────────────────────────\n   1 │        1      2.3   ab               2  2022-01-02\n   2 │       10     -2.1   cd               3  missing    \n   3 │        4      1.34  dd         missing  2022-02-13","category":"page"},{"location":"man/tutorial_basic/#Writing-a-data-set-to-disk","page":"Basic","title":"Writing a data set to disk","text":"","category":"section"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"The DLMReader package provides the filewriter function for writing a data set as a flat file into disk. The function uses comma as default delimiter, however, the user can pass any other delimiter via the delimiter keyword argument.","category":"page"},{"location":"man/tutorial_basic/","page":"Basic","title":"Basic","text":"julia> filewriter(\"t_file.csv\", tutorial)","category":"page"},{"location":"man/informat/#Informats","page":"Informats","title":"Informats","text":"","category":"section"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"The DLMReader package uses informat to call a special type of functions on raw text before parsing its values. This gives a flexible feature to DLMReader and enables it to handle messy delimited files.","category":"page"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"The package is shipped with some pre-registered informats which are listed (new informats may be added to future releases) below:","category":"page"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"STRIP!: Remove leading and trailing blanks\nCOMMA: Remove $, and ,(thousands separators) from the numbers\nCOMMAX: Treat , as decimal point, and removes €, and . (thousands separators) from numbers\nNA!: Treat NA, na, Na, nA as missing\nBOOL!: Convert any form of True and False to 1 and 0, respectively\nACC!: Treat numbers in parentheses (Accounting format) as negative values, i.e. it replaces ( with - and ) with blank.\nCOMPRESS!: Remove all blanks (0x20)","category":"page"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"Users can define their own informats, which is basically a function with one positional argument. The function must accept a special mutable string and returns its modified value (or returns a subset of it). To use the new defined function as informat, user must register it by calling the register_informat function.","category":"page"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"Note that if the function definition is changed, DLMReader uses the new definition and user MUST re-register it to avoid extra allocation.","category":"page"},{"location":"man/informat/#Supported-string-manipulation-functions","page":"Informats","title":"Supported string manipulation functions","text":"","category":"section"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"The function used for informat must accept a special mutable string type and return it. Thus, user must only modify the input argument in-place. Currently, few string manipulation functions are optimised for this purpose - For small to medium size files, user can use any other functions, which support working with AbstractString, for manipulating the input argument: (in the following paragraph x is referring to the positional argument of the user defined informat)","category":"page"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"isequal: User can use isequal to check if the input function or a sub-string of it is equal to a string.\nsetindex!: To assign a string to the input argument, use setindex!(x, \"newtext\") syntax. If the length of new text is smaller than x, it will be padded with blank (0x20), if it is longer than x it will be truncated.\nreplace!: User can use replace! to replace part of the input argument. For instance replace!(x, \"12\"=>\"21\") replace every occurrence of \"12\" with \"21\". Note that shorter replacing text will be padded with blank and longer ones will be truncated.\noccursin: occursin(\"text\", x) determines whether the first argument is a substring of the second.\nUser can use regular expressions too, i.e. occursin(r::Regex, x)\ncontains: contains(x, \"text\") determines whether the second argument is a substring of the first.\nUser can use regular expressions too, i.e. contains(x, r::Regex)\nfindfirst: User can search for the first occurrence of the index of a regular expression pattern via the allocation free function findfirst, i.e. findfirst(r::Regex, x)\nfindnext: User can search for the next occurrence of the index of a regular expression pattern vai the allocation free function findnext, i.e. findnext(r::Regex, x, i)\nremove!: It removes some text (replace it with blanks) from the input argument. It can removes a String constant or a sequence of string location provided as a range, e.g.\nremove!(x, \"text\")\nremove!(x, 2:4)","category":"page"},{"location":"man/informat/","page":"Informats","title":"Informats","text":"Users can test the new defined informats by calling DLMReader.test(f, text) where f is the user defined informat and text is a given string.","category":"page"},{"location":"#DLMReader.jl","page":"Introduction","title":"DLMReader.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the DLMReader.jl documentation!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with the DLMReader.jl package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DLMReader is a delimited file reader/writer for Julia. It reads/writes delimited file into/from InMemoryDatasets.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is designed to be flexible, efficient, and performant.","category":"page"},{"location":"#Package-manual","page":"Introduction","title":"Package manual","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"man/tutorial_basic.md\",\n          \"man/tutorial_adv.md\",\n          \"man/read.md\",\n          \"man/informat.md\",\n          \"man/performance.md\",\n          \"man/gallery.md\"]\nDepth = 2","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without DLMReader. qualifier after loading the DLMReader.jl package with using DLMReader) types and functions are considered a part of the public API of the DLMReader.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"man/performance/#Performance-tips","page":"Performance Tips","title":"Performance tips","text":"","category":"section"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"This section contains some performance tips which can improve the experience of working with DLMReader. These tips are specially important when reading a huge file.","category":"page"},{"location":"man/performance/#Avoid-using-String-type-for-large-data-sets","page":"Performance Tips","title":"Avoid using String type for large data sets","text":"","category":"section"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"Using String causes garbage collection and it must be avoided when possible. ","category":"page"},{"location":"man/performance/#Pass-types-for-very-wide-files","page":"Performance Tips","title":"Pass types for very wide files","text":"","category":"section"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"By default, filereader uses 20 lines of the input file to guess the types of each column. For very wide files, this is not very efficient, and passing the types keyword argument or setting a lower number for gussingrows can significantly improve the performance.","category":"page"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"julia> using InMemoryDatasets\n\njulia> ds = Dataset(rand([1.1,2.2,3.4], 100, 100000), :auto);\n\njulia> filewriter(\"_tmp.csv\", ds, buffsize = 2^25, lsize = 500000);\n\njulia> @time ds = filereader(\"_tmp.csv\", buffsize = 2^21, lsize = 2^20, types = fill(Float64, 10^5));\n  1.084718 seconds (499.34 k allocations: 254.858 MiB, 2.08% gc time)\n\njulia> @time ds = filereader(\"_tmp.csv\", buffsize = 2^21, lsize = 2^20, guessingrows = 2);\n  1.100339 seconds (1.40 M allocations: 266.832 MiB, 0.83% gc time)","category":"page"},{"location":"man/performance/#Use-informat-to-improve-performance","page":"Performance Tips","title":"Use informat to improve performance","text":"","category":"section"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"In many cases using informat can improve the performance of reading huge files. For instances, if there are two columns in the input file which both are Date but with different DataFormat, using informat to convert them into the same DateFormat improves the performance,","category":"page"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"julia> function DINFMT!(x)\n           replace!(x, \"/\" => \"-\")\n       end\njulia> register_informat(DINFMT!)\n  [ Info: Informat DINFMT! has been registered\n  \njulia> ds = filereader(IOBuffer(\"\"\"date1,date2\n       2020-1-1,2020/1/1\n       2020-2-2,2020/2/2\n       \"\"\"), types = [Date, Date], informat = Dict(2 => DINFMT!))\n2×2 Dataset\n Row │ date1       date2      \n     │ identity    identity   \n     │ Date?       Date?      \n─────┼────────────────────────\n   1 │ 2020-01-01  2020-01-01\n   2 │ 2020-02-02  2020-02-02","category":"page"},{"location":"man/performance/#Passing-lsize-can-improve-writing-speed","page":"Performance Tips","title":"Passing lsize can improve writing speed","text":"","category":"section"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"When the input data set contains many columns with float types, passing lsize can improve the performance significantly. This is due to the fact that the filewriter is very conservative when converting floats to string. In the following example we can have a rough idea about how many characters exists in each row of the data set, thus, passing our estimate to the filewriter function improves the performance.","category":"page"},{"location":"man/performance/","page":"Performance Tips","title":"Performance Tips","text":"julia> using InMemoryDatasets\n\njulia> ds = Dataset(rand([1.1,2.2,3.4], 100, 100000), :auto);\n\njulia> @time filewriter(\"_tmp.csv\", ds, buffsize = 2^25);\n  1.378465 seconds (54.90 M allocations: 2.547 GiB, 19.67% gc time)\n\njulia> @time filewriter(\"_tmp.csv\", ds, buffsize = 2^25, lsize = 500000);\n  0.214730 seconds (9.80 M allocations: 516.580 MiB)","category":"page"},{"location":"man/tutorial_adv/#Tutorial-Advanced","page":"Advanced","title":"Tutorial - Advanced","text":"","category":"section"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"This section provides an advanced introduction for using the DLMReader package to read a delimited file into Julia. To start using the package enter the following expression in a Julia session,","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> using DLMReader","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"If you have not installed the package yet, you will be prompt to do it so.","category":"page"},{"location":"man/tutorial_adv/#Reading-the-yellow-taxi-file","page":"Advanced","title":"Reading the yellow taxi file","text":"","category":"section"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"The yellow_subset.csv file is a small subset of taxi movements in New York city in 2010. ","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> taxi_file = joinpath(dirname(pathof(DLMReader)),\n                                \"..\", \"docs\", \"src\", \"assets\", \"yellow_subset.csv\"\n                            );","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"In this tutorial we use the filereader function to read this file into Julia. At the first attempt we directly use the filereader function to read this data into Julia, however, since the file can be huge we only limit our parsing to few observations (examining the structure of the input file).","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> taxi = filereader(taxi_file, limit = 4)\n┌ Info: There might be less observations in the input file at line 2 (observation 1) than the number of columns in the output dataset.\n└  \n4×18 Dataset\n Row │ vendor_id  pickup_datetime      dropoff_datetime     passenger_count  trip_distance  pickup_longitude  pickup_latitude  rate_code  store_and_fwd_flag  dropoff_longitude   ⋯\n     │ identity   identity             identity             identity         identity       identity          identity         identity   identity            identity            ⋯\n     │ String?    String?              String?              Int64?           Float64?       Float64?          Float64?         Int64?     Int64?              Float64?            ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ \\r         missing              missing                      missing      missing        missing          missing         missing             missing       missing        ⋯\n   2 │ CMT        2010-03-15 15:29:46  2010-03-15 15:34:09                1            0.8          -74.0047          40.7343          1                   0           -73.9936\n   3 │ CMT        2010-03-15 11:44:31  2010-03-15 11:48:48                1            0.3          -73.9584          40.7729          1                   0           -73.9636\n   4 │ CMT        2010-03-15 11:07:30  2010-03-15 11:21:39                2            2.2          -73.9574          40.78            1                   0           -73.9838\n                                                                                                                                                                  8 columns omitted","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Note the first row of the output data set is strange, and the output data set is truncated, thus, we cannot see the detected type of columns. We first fix the problem with the first observation. Since the first cell is filled with \"\\r\" we should suspect that the end-of-line character for this file might be detected incorrectly. The filereader package allows user to pass the end-of-line character via the linebreak keyword argument. In general, \"\\n\" is the end-of-line character for most delimited file, however, in some operating systems \"\\r\", \"\\r\\n\", etc might be used for this purpose. Using trial and error (there are other ways rather than trial and error) we noticed that the end-of-line for this file is \"\\r\\n\", and there is an extra \"\\n\" in the first line of the file which has puzzled the automatic detection. Thus, we rerun the code and pass the linebreak keyword argument to fix the first issue of this file,","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> taxi = filereader(taxi_file, limit = 4, linebreak = ['\\r','\\n'])\n4×18 Dataset\n Row │ vendor_id  pickup_datetime      dropoff_datetime     passenger_count  trip_distance  pickup_longitude  pickup_latitude  rate_code  store_and_fwd_flag  dropoff_longitude   ⋯\n     │ identity   identity             identity             identity         identity       identity          identity         identity   identity            identity            ⋯\n     │ String?    String?              String?              Int64?           Float64?       Float64?          Float64?         Int64?     Int64?              Float64?            ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ CMT        2010-03-15 15:29:46  2010-03-15 15:34:09                1            0.8          -74.0047          40.7343          1                   0           -73.9936   ⋯\n   2 │ CMT        2010-03-15 11:44:31  2010-03-15 11:48:48                1            0.3          -73.9584          40.7729          1                   0           -73.9636\n   3 │ CMT        2010-03-15 11:07:30  2010-03-15 11:21:39                2            2.2          -73.9574          40.78            1                   0           -73.9838\n   4 │ CMT        2010-03-15 14:57:33  2010-03-15 15:10:26                1            4.1          -74.016           40.7151          1                   0           -73.9904\n                                                                                                                                                                  8 columns omitted","category":"page"},{"location":"man/tutorial_adv/#Passing-data-types","page":"Advanced","title":"Passing data types","text":"","category":"section"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"In general, providing the data type of columns improve the efficiency of reading delimited file. To provide such information, we look at the detected types in taxi and pass the right data types. To examine the detected types of a data set, we should use the content and describe functions from the InMemoryDatasets package.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> using InMemoryDatasets\n\njulia> content(taxi)\n4×18 Dataset\n   Created: 2022-05-13T15:00:55.868\n  Modified: 2022-05-13T15:00:55.868\n      Info: \n-----------------------------------\nColumns information \n┌─────┬────────────────────┬──────────┬─────────┐\n│ Row │ col                │ format   │ eltype  │\n├─────┼────────────────────┼──────────┼─────────┤\n│   1 │ vendor_id          │ identity │ String  │\n│   2 │ pickup_datetime    │ identity │ String  │\n│   3 │ dropoff_datetime   │ identity │ String  │\n│   4 │ passenger_count    │ identity │ Int64   │\n│   5 │ trip_distance      │ identity │ Float64 │\n│   6 │ pickup_longitude   │ identity │ Float64 │\n│   7 │ pickup_latitude    │ identity │ Float64 │\n│   8 │ rate_code          │ identity │ Int64   │\n│   9 │ store_and_fwd_flag │ identity │ Int64   │\n│  10 │ dropoff_longitude  │ identity │ Float64 │\n│  11 │ dropoff_latitude   │ identity │ Float64 │\n│  12 │ payment_type       │ identity │ String  │\n│  13 │ fare_amount        │ identity │ Float64 │\n│  14 │ surcharge          │ identity │ Int64   │\n│  15 │ mta_tax            │ identity │ Float64 │\n│  16 │ tip_amount         │ identity │ Int64   │\n│  17 │ tolls_amount       │ identity │ Int64   │\n│  18 │ total_amount \\n    │ identity │ Float64 │\n└─────┴────────────────────┴──────────┴─────────┘","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Note that the type detection for some columns is incorrect, e.g. pickup_datetime, dropoff_datetime, surcharge, etc. In the next step we pass the incorrectly detected columns via the types and dtformat keyword arguments,","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> taxi = filereader(taxi_file, limit = 4, linebreak = ['\\r','\\n'], \n                            types = Dict([14,16,17] .=> Float64), \n                            dtformat = Dict(2:3 .=> dateformat\"y-m-d H:M:S\"))\n4×18 Dataset\n Row │ vendor_id  pickup_datetime      dropoff_datetime     passenger_count  trip_distance  pickup_longitude  pickup_latitude  rate_code  store_and_fwd_flag  dropoff_longitude   ⋯\n     │ identity   identity             identity             identity         identity       identity          identity         identity   identity            identity            ⋯\n     │ String?    DateTime?            DateTime?            Int64?           Float64?       Float64?          Float64?         Int64?     Int64?              Float64?            ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ CMT        2010-03-15T15:29:46  2010-03-15T15:34:09                1            0.8          -74.0047          40.7343          1                   0           -73.9936   ⋯\n   2 │ CMT        2010-03-15T11:44:31  2010-03-15T11:48:48                1            0.3          -73.9584          40.7729          1                   0           -73.9636\n   3 │ CMT        2010-03-15T11:07:30  2010-03-15T11:21:39                2            2.2          -73.9574          40.78            1                   0           -73.9838\n   4 │ CMT        2010-03-15T14:57:33  2010-03-15T15:10:26                1            4.1          -74.016           40.7151          1                   0           -73.9904\n                                                                                                                                                                  8 columns omitted","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Passing the date format of the DataTime columns is sufficient for parsing their values. Thus, in the previous code, we only passed the dtformat keyword argument for the second and third column.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"In the next step, we store the data types of the columns in an array and pass it to the filereader function to process the whole file. Note that for date values in non-standard form we need to pass the dtformat keyword argument.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> _tmp = content(taxi, output = true)[2];\n\njulia> alltypes = identity.(_tmp[:, :eltype]);\n\njulia> taxi = filereader(taxi_file, linebreak = ['\\r','\\n'], \n                            types = alltypes, \n                            dtformat = Dict(2:3 .=> dateformat\"y-m-d H:M:S\"))\n┌ Info: There might be more observations in the input file at line 11 (observation 10) than the number of columns in the output dataset.\n└  CMT,2010-03-15 15:35:04,2010-03-15 16:00:07,1,5.2000000000000002,-73.993639000000002,40.720208999999997,1,,,-73.946438000000001,40.778773999999999,Cas,16.100000000000001,0,0.5,0,0,16.600000000000001.\n┌ Warning: There are problems with parsing the input file at line 11 (observation 10) : \n│ Column 13 : fare_amount::Float64 : Read from buffer (\"Cas\")\n│  the values are set as missing.\n│ MORE DETAILS: \n│ vendor_id::String = CMT, pickup_datetime::DateTime = 2010-03-15T15:35:04, dropoff_datetime::DateTime = 2010-03-15T16:00:07, passenger_count::Int64 = 1, trip_distance::Float64 = 5.2, pickup_longitude::Float64 = -73.993639, pickup_latitude::Float64 = 40.720209, rate_code::Int64 = 1, store_and_fwd_flag::Int64 = missing, dropoff_longitude::Float64 = missing, dropoff_latitude::Float64 = -73.946438, payment_type::String = 40.778773999999999, fare_amount::Float64 = missing, surcharge::Float64 = 16.1, mta_tax::Float64 = 0.0, tip_amount::Float64 = 0.5, tolls_amount::Float64 = 0.0, total_amount::Float64 = 0.0\n│ CMT,2010-03-15 15:35:04,2010-03-15 16:00:07,1,5.2000000000000002,-73.993639000000002,40.720208999999997,1,,,-73.946438000000001,40.778773999999999,Cas,16.100000000000001,0,0.5,0,0,16.600000000000001\n└ @ DLMReader ...\n20×18 Dataset\n Row │ vendor_id  pickup_datetime      dropoff_datetime     passenger_count  trip_distance  pickup_longitude  pickup_latitude  rate_code  store_and_fwd_flag  dropoff_longitude   ⋯\n     │ identity   identity             identity             identity         identity       identity          identity         identity   identity            identity            ⋯\n     │ String?    DateTime?            DateTime?            Int64?           Float64?       Float64?          Float64?         Int64?     Int64?              Float64?            ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ CMT        2010-03-15T15:29:46  2010-03-15T15:34:09                1            0.8          -74.0047          40.7343          1                   0           -73.9936   ⋯\n   2 │ CMT        2010-03-15T11:44:31  2010-03-15T11:48:48                1            0.3          -73.9584          40.7729          1                   0           -73.9636\n  ⋮  │     ⋮               ⋮                    ⋮                  ⋮               ⋮               ⋮                 ⋮             ⋮              ⋮                   ⋮           ⋱\n  19 │ CMT        2010-03-15T14:31:04  2010-03-15T14:40:03                1            0.9          -73.9977          40.7412          1                   0           -73.9834\n  20 │ CMT        2010-03-15T12:20:25  2010-03-15T12:26:38                1            0.9          -73.9983          40.7454          1                   0           -73.9954\n                                                                                                                                                      8 columns and 16 rows omitted","category":"page"},{"location":"man/tutorial_adv/#Examining-the-warnings","page":"Advanced","title":"Examining the warnings","text":"","category":"section"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"The last code produces some info and warning messages which alert the existence of some issues in reading process. When the filereader reads all the columns but fails to reach the end of the line, it produce some info to alert user. The Info message contains the information about location of issue and the raw text of the input line. ","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Additionally, when the filereader cannot parse a particular values, it provides some warning messages to help users to investigate the problem. The message contains the details and the location of the problem.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"In the above example, we can see that the 11th line of the input file has an issue. An investigation reveals that the problem is due to extra \",\" in place of missing values, i.e. near \"1,,,-73.946438000000001\". This causes a shift in values, thus, the filereader function fails to parse the value of the 13th column. This problem is a data entry problem and we cannot fix it unless there is a systematic pattern for such problems. Fortunately, for this specific file the patter is fixed for all lines so we can exploit some features of the DLMReader package to fix the issue.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"To fix the aforementioned problem, we define a new informat which reads a line from the input file and modify its contents in-place and pass this to the filereader function via  line_informat.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"The logic that we are going to follow is \"replacing the second , in ,,, with space\". Note that this may not make sense for any other files, thus, user must search for a particular  pattern in each case.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"The line_informat keyword argument accepts a registered informat which is a function with one positional argument, a special type of mutable string.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Note that the line_informat informat is called on each line of the input file, thus, use low level programming to avoid any allocation.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Note that the last column name has an extra '\\n'. To fix it, user can call rename!(taxi, \"total_amount \\n\" => \"total_amount\").","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> function LINFMT!(x)\n            replace!(x, \",,,\" => \", ,\")\n        end\njulia> register_informat(LINFMT!)\n    [ Info: Informat LINFMT! has been registered\n\njulia> taxi = filereader(taxi_file, linebreak = ['\\r','\\n'], \n                            types = alltypes,\n                            dtformat = Dict(2:3 .=> dateformat\"y-m-d H:M:S\"), \n                            line_informat = LINFMT!)\n20×18 Dataset\n Row │ vendor_id  pickup_datetime      dropoff_datetime     passenger_count  trip_distance  pickup_longitude  pickup_latitude  rate_code  store_and_fwd_flag  dropoff_longitude   ⋯\n     │ identity   identity             identity             identity         identity       identity          identity         identity   identity            identity            ⋯\n     │ String?    DateTime?            DateTime?            Int64?           Float64?       Float64?          Float64?         Int64?     Int64?              Float64?            ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ CMT        2010-03-15T15:29:46  2010-03-15T15:34:09                1            0.8          -74.0047          40.7343          1                   0           -73.9936   ⋯\n   2 │ CMT        2010-03-15T11:44:31  2010-03-15T11:48:48                1            0.3          -73.9584          40.7729          1                   0           -73.9636\n  ⋮  │     ⋮               ⋮                    ⋮                  ⋮               ⋮               ⋮                 ⋮             ⋮              ⋮                   ⋮           ⋱\n  20 │ CMT        2010-03-15T12:20:25  2010-03-15T12:26:38                1            0.9          -73.9983          40.7454          1                   0           -73.9954\n                                                                                                                                                      8 columns and 17 rows omitted\n\njulia> rename!(taxi, \"total_amount \\n\" => \"total_amount\")","category":"page"},{"location":"man/tutorial_adv/#Dealing-with-String-columns","page":"Advanced","title":"Dealing with String columns","text":"","category":"section"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"Columns with String type cause performance issue for large data sets. If those columns contains only a few unique values then we must convert the corresponding columns to PooledArray. However, if this is not possible we must read those columns into Julia as fixed-length string types. ","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"User can read the columns as fixed-length string and convert them into PooledArray later.","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"To convert the columns with String type to PooledArray, user should use the modify! function from the InMemoryDatasets package,","category":"page"},{"location":"man/tutorial_adv/","page":"Advanced","title":"Advanced","text":"julia> using PooledArrays\n\njulia> modify!(taxi, names(taxi, AbstractString) => PooledArray);\n\njulia> describe(taxi)\n18×7 Dataset\n Row │ column              n         nmissing  mean      std        minimum              maximum             \n     │ identity            identity  identity  identity  identity   identity             identity            \n     │ String?             Any       Any       Any       Any        Any                  Any                 \n─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ vendor_id           20        0         nothing   nothing    CMT                  CMT\n   2 │ pickup_datetime     20        0         nothing   nothing    2010-03-15T11:07:30  2010-03-15T15:35:04\n   3 │ dropoff_datetime    20        0         nothing   nothing    2010-03-15T11:21:39  2010-03-15T16:00:07\n   4 │ passenger_count     20        0         1.1       0.307794   1                    2\n   5 │ trip_distance       20        0         2.11      2.15917    0.1                  9.2\n   6 │ pickup_longitude    20        0         -73.9863  0.0186699  -74.016              -73.9574\n   7 │ pickup_latitude     20        0         40.7486   0.022824   40.7151              40.7972\n   8 │ rate_code           20        0         1.0       0.0        1                    1\n   9 │ store_and_fwd_flag  19        1         0.0       0.0        0                    0\n  10 │ dropoff_longitude   20        0         -73.9782  0.0154007  -74.0016             -73.9464\n  11 │ dropoff_latitude    20        0         40.7603   0.0178604  40.7196              40.7838\n  12 │ payment_type        20        0         nothing   nothing    Cas                  Cre\n  13 │ fare_amount         20        0         8.44      5.62741    2.5                  27.7\n  14 │ surcharge           20        0         0.0       0.0        0.0                  0.0\n  15 │ mta_tax             20        0         0.5       0.0        0.5                  0.5\n  16 │ tip_amount          20        0         0.368     0.830127   0.0                  3.0\n  17 │ tolls_amount        20        0         0.0       0.0        0.0                  0.0\n  18 │ total_amount        20        0         9.308     5.74365    3.0                  28.2\n","category":"page"}]
}
